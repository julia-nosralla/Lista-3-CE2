--- 
title: "API's"
format: 
  revealjs:
    embed-resources: true
    theme: default
    title-slide-attributes: 
      data-background-image: background.jpg
editor: visual
transition: slide
center: true
---

# O que são API's? {background-image=background.jpg}

## Definição {background-image=background.jpg}

- API é a sigla para Application Programming Interface.

- É uma interface de comunicação que um sistema oferece para que outros sistemas acessem suas funções, dados, serviços e recursos.

- Possibilitam utilizar funções de um aplicativo dentro de outro, facilitando o trabalho dos desenvolvedores.

- Permitem o acesso a dados, sem a necessidade de raspagem de superfície (scraping) ou coleta manual.

# Tipos de API {background-image=background.jpg}

## API's privadas {background-image=background.jpg}

São internas de uma empresa e são usadas apenas para conectar sistemas e dados dentro da empresa.

## API's públicas {background-image=background.jpg}

São abertas ao público e podem ser usadas por qualquer pessoa. 

Pode ou não haver alguma autorização e/ou custo associado a esses tipos de APIs.

## API's de parceiros {background-image=background.jpg}

Acessíveis apenas por desenvolvedores externos autorizados, em nome de empresas parceiras.

## Arquitetura e comunicação {background-image=background.jpg}

- **REST (Representational State Transfer)**: simples e intuitiva, escalável e amplamente adotada

- **SOAP (Simple Object Access Protocol)**: padrões rigorosos, maior segurança

- **GraphQL**: complexa, flexível e eficiente, permite a requisição de dados específicos

- **RPC (Remote Procedure Call)**: uso procedural simples, mas pode ser complexa para gerenciamento de recursos

# Como funcionam? {background-image=background.jpg}

## Visão geral {background-image=background.jpg}

- As APIs funcionam através de um protocolo, um conjunto de instruções, padrões e regras que definem como os sistemas devem se comunicar.

- Elas estabelecem métodos de requisição, formatos de dados a serem recebidos ou retornados, autenticação e autorização de acesso, entre outros aspectos técnicos. 

- Quando um software utiliza uma API, ele envia uma requisição seguindo as diretrizes estabelecidas pela interface, e em resposta recebe os dados ou realiza as ações desejadas.

## Etapas {background-image=background.jpg}

1. Uma **requisição** é enviada ao sistema que disponibiliza uma API (servidor) por um cliente (que pode ser um navegador, um aplicativo móvel ou outro servidor). Geralmente segue o protocolo HTTP (Hypertext Transfer Protocol).

2. O servidor faz o **processamento** da requisição, que pode envolver uma consulta a uma base de dados ou acesso a outras funcionalidades.

3. O servidor envia uma **resposta** ao cliente. Geralmente inclui um código de *status*, indicativo de sucesso ou falha na requisição, e os dados solicitados.

## Métodos de requisição HTTP {background-image=background.jpg}

Os principais métodos de requisição são:

- `get`: requisição para obter, visualizar ou extrair dados;

- `post`: requisição para criar ou enviar novos dados;

- `put`: requisição para editar ou atualizar dados;

- `delete`: requisição para remover dados.

## Códigos de Status HTTP {background-image=background.jpg}

-   **1xx (Informacional)**: Requisição recebida, processo em andamento.

-   **2xx (Exitoso)**: Requisição recebida com sucesso e aceita.

-   **3xx (Redirecionamento)**: É necessário tomar alguma medida para completar a requisição.

-   **4xx (Erro de Cliente)**: A requisição apresenta problemas de sintaxe ou não pôde ser completada por algum motivo. (401, 404)

-   **5xx (Erro de Servidor)**: O servidor falhou em completar uma requisição válida.
 
## Requisições e chaves de acesso {background-image=background.jpg}

- É comum que alguns sistemas exijam o uso de chaves para limitar e controlar a quantidade de requisições de acesso.

- Essa medida visa a segurança do próprio sistema, garantindo a sua disponibilidade e evitando por exemplo ataques de negação de serviço (DoS).

## Requisições e chaves de acesso {background-image=background.jpg}

- Além de ajudar a detectar atividades suspeitas, as chaves de acesso também servem para identificar, monitorar e registrar quem consome a API, a fim de obter *insights* a respeito dos padrões de uso do serviço e aprimorá-lo.

- Alguns sistemas monetizam o consumo das API's.

- Ainda assim, alguns sistemas permitem que sejam feitas requisições *keyless*.

## Endpoints {background-image=background.jpg}

- *Endpoints* são funções ou recursos da API que, dado sua estrutura hierárquica (aninhada, ou em árvore), podem ser acessadas diretamente pelo sistema cliente. 

- Para acessar um *endpoint* específico dentro de uma API, basta utilizarmos o URL (*Uniform Resource Locator*) principal da API seguido do caminho correspondente a esse *endpoint*.

## Endpoints {background-image=background.jpg}

### *Placeholders*

É comum utilizarmos chaves `{}` como *placeholders* ao nos referirmos a *endpoints*.

### Parâmetros de consulta

Podemos, ainda utilizar parâmetros simples de consulta para filtrar os resultados de uma requisição. Ex.:

```/usuarios?sexo=masculino```

Operadores: `&`, `|`

# {background-image=jason.PNG}

## JSON (JavaScript Object Notation) {background-image=background.jpg}

- Padrão de indústria
- Interoperabilidade
- Legibilidade
- Parseável
- Simples, leve e eficiente
- Vulnerabilidade (DoS, XSS, vazamentos)

## JSON vs. XML {background-image=background.jpg}

||JSON|XML|
|-|-|-|
|Vantagens|Sintaxe, legibilidade</br>Tipos de dados</br>Performance</br>Interoperabilidade|Validação, integridade e consistência</br>Inclusão de metadados</br>Robustez|
|Desvantagens|Ausência de metadados</br>Não comentável</br>Vulnerabilidade|Verbosidade</br>Lentidão e maior uso de recursos|

## JSON vs. CSV {background-image=background.jpg}

||JSON|CSV|
|-|-|-|
|Vantagens|Suporte a estruturas aninhadas/hierarquizadas</br>Tipos de dados e estruturas|Simplicidade e legibilidade</br>Leveza e eficiência</br>Compatibilidade|
|Desvantagens|Legibilidade para dados simples, tabulares</br>Tamanho, sintaxe adicional|Inadequado para dados complexos</br>Inconsistência (encoding)|

# Exemplos de consumo de API usando R {background-image=background.jpg}

Vejamos alguns exemplos de como interagir com APIs diferentes utilizando linguagem R.

## PokéAPI (Keyless) {background-image=background.jpg}

[Temos que pegar!](https://pokeapi.co/)

# {background-image=background.jpg}

```{r, warning=FALSE, message=FALSE}
#| echo: TRUE
if (!require("httr", character.only = TRUE)) {
  install.packages("httr")}
if (!require("jsonlite", character.only = TRUE)) {
  install.packages("jsonlite")}

library(httr)
library(jsonlite)

#Construir URL
 
pokemon_base <- "https://pokeapi.co/api/v2/pokemon/"

pokemon_endpoint <- ""

pokemon_url <- base::paste0(pokemon_base, pokemon_endpoint)

pokemon_url
```

## Requisição (API call) {background-image=background.jpg}

```{r}
#| echo: TRUE
pokemon_call <- httr::GET(pokemon_url)
```

Retorna uma lista! Nesse caso, com 10 elementos, sendo os de interesse: "url", "status_code" e "content".

## Visualizar a resposta da API {background-image=background.jpg}

Para termos uma visão geral resumida do objeto, podemos rodar:

```{r}
#| echo: TRUE
pokemon_call
```

# {background-image=background.jpg}

Vamos tentar dar uma olhada no conteúdo retornado:
  
```{r}
#| echo: TRUE
pokemon_call$content
```

Parece que os dados ainda estão inacessíveis. Aqui, obtemos os dados binários do arquivo em formato hexadecimal.

# {background-image=background.jpg}

Agora, vamos converter esses binários em string para ver o conteúdo do arquivo `json`. 

```{r}
#| echo: TRUE
pokemon_content <- httr::content(pokemon_call, as = "text")

pokemon_content
```

Retorna os dados em formato de texto, mas ainda truncado.

# {background-image=background.jpg}

Precisamos converter esse string json em uma tabela. Para isso, lançamos mão da função `fromJSON()` do `jsonlite`.

```{r}
#| echo: TRUE
pokemonJSON <- jsonlite::fromJSON(pokemon_content, flatten = TRUE)

pokemonJSON
```
Inicialmente, obtemos uma lista

# {background-image=background.jpg}

Se explorarmos qualquer um dos objetos `pokemonJSON`, notaremos que o que nos interessa está localizado dentro de `results`.

```{r}
#| echo: TRUE
pokemonJSON$results
```

## Acessar os dados de cada pokémon {background-image=background.jpg}

Uma maneira seria alterar a URL base, adicionando endpoints:
  
```{r}
#| echo: TRUE
pokemon_url <- "https://pokeapi.co/api/v2/pokemon/{endpoint}"
```

Nesse sentido, separar a base do URL dos endpoints é muito conveniente.

# {background-image=background.jpg}

Por exemplo, podemos usar essa API para obtermos os stats do Growlithe:
  
```{r}
#| echo: TRUE
#| results: "hide"

pokemon_base <- "https://pokeapi.co/api/v2/pokemon/"

growlithe_endpoint <- "58"

growlithe_url <- base::paste0(pokemon_base, growlithe_endpoint)

growlithe_call <- httr::GET(growlithe_url)

growlithe_content <- httr::content(growlithe_call, as = "text")

growlithe_JSON <- jsonlite::fromJSON(growlithe_content, flatten = TRUE)

growlithe_stats <- data.frame(growlithe_JSON$stats)

growlithe_stats
```

# {background-image=background.jpg}

```{r}
#| echo: FALSE
growlithe_stats
```

## Aplicações {background-image=background.jpg}

<https://pokemoncries.com/>

## API OpenWeather {background-image=background.jpg}

- [https://openweathermap.org/api](https://openweathermap.org/api)

## Obtendo a latitude e longitude da cidade {background-image=background.jpg}

Utilizaremos Brasília como exemplo

```{r}
#| echo = FALSE
key <- "338cd4eb8b0a910c8b71a4b53af0544b"
```

```{r}
#| echo: TRUE

url <- base::paste0("https://api.openweathermap.org/geo/1.0/direct?q=Brasília&appid=", key)

loc <- httr::GET(url)

loc$status_code
```

Com base no código de status, verificamos que a requisição foi aceita.

## Conversão do conteúdo {background-image=background.jpg}

```{r}
loc_texto <- httr::content(loc, as = "text")

loc_texto
```

Nesse arquivo, temos o nome da cidade em várias línguas e, ao final, as informações sobre sua localização

# {background-image=background.jpg}

```{r}
#| echo: TRUE
loc_JSON <- jsonlite::fromJSON(loc_texto)

latitude <- loc_JSON$lat
longitude <- loc_JSON$lon
```

Transformamos a latitude e longitude obtidas em objetos que serão utilizados como parâmetros na URL da próxima requisição.

## Requisição do clima atual em Brasília {background-image=background.jpg}

O procedimento é o mesmo:

```{r}
#| echo: TRUE

url2 <- base::paste0("https://api.openweathermap.org/data/2.5/weather?lat=", latitude, "&lon=", longitude, "&appid=", key, "&units=metric")
#Por default, esta API retorna a temperatura em Kelvin. Para obter a temperatura em graus Celsius, utilizamos o parâmetro "units=metric"

dados <- httr::GET(url2)
dados$status_code

conteudo_dados <- httr::content(dados, as = "text")

conteudo_JSON <- jsonlite::fromJSON(conteudo_dados)
```

# {background-image=background.jpg}

Obtemos a lista:

```{r}
#| echo: TRUE
conteudo_JSON
```

# {background-image=background.jpg}

```{r}
#| echo: TRUE

conteudo_JSON[["main"]][["temp"]]
```

# Sugestões de API's públicas {background-image=background.jpg}

- [publicapis.io](https://publicapis.io)
- [Catálogo de APIs Governamentais](https://www.gov.br/conecta/catalogo)

# Referências {background-image=background.jpg}

- [https://www.alura.com.br/artigos/api](https://www.alura.com.br/artigos/api)
- [https://blog.platformbuilders.io/o-que-sao-apis/](https://blog.platformbuilders.io/o-que-sao-apis/)
- [https://aws.amazon.com/pt/compare/the-difference-between-json-xml/](https://aws.amazon.com/pt/compare/the-difference-between-json-xml/)
-[https://blog.betrybe.com/json/](https://blog.betrybe.com/json/)
